/**
 * This file was automatically generated by the ICG based on the file:
 * /root/trick_sims/SIM_cannon_analytic/S_source.hh
 * This file contains database parameter declarations specific to the
 * data structures and enumerated types declared in the above file.
 * These database parameters are used by the Trick input and
 * data recording processors to gain access to important simulation
 * variable information.
 */

#define TRICK_IN_IOSRC
#include <stdlib.h>
#include "trick/MemoryManager.hh"
#include "trick/attributes.h"
#include "trick/parameter_types.h"
#include "trick/ClassSizeCheck.hh"
#include "trick/UnitsMap.hh"
#include "trick/checkpoint_stl.hh"
#include "/root/trick_sims/SIM_cannon_analytic/S_source.hh"

extern "C" {

ATTRIBUTES attrSimEnvironment[] = {
{"", "", "1", "", "",
  "",
  15,TRICK_VOID, 0, 0, 0, Language_CPP, 0,
  0, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL} };

} //extern "C"


void init_attrSimEnvironment() {

    static int initialized ;
    if (initialized) {
        return;
    }
    initialized = 1;

}

extern "C" {

void init_attrSimEnvironment_c_intf() {
    init_attrSimEnvironment() ;
}

size_t io_src_sizeof_SimEnvironment() {
    return sizeof(SimEnvironment) ;
}

void* io_src_allocate_SimEnvironment(int num) {
    SimEnvironment* temp = (SimEnvironment*)calloc(num, sizeof(SimEnvironment));
    for (int ii = 0; ii < num; ++ii) {
        new(&temp[ii]) SimEnvironment();
    }
    return (void*)temp;
}

void io_src_destruct_SimEnvironment(void* address __attribute__((unused)), int num __attribute__((unused))) {
SimEnvironment* temp = (SimEnvironment*)address;
    for (int ii = 0; ii < num; ++ii) {
        temp[ii].~SimEnvironment();
    }
}

void io_src_delete_SimEnvironment(void* address) {
    delete (SimEnvironment*)address;
}

} //extern "C"

struct UnitsMapSimEnvironment {
} umSimEnvironment;

extern "C" {

ATTRIBUTES attrSysSimObject[] = {
{"sched", "Trick::Executive", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  120, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"", "", "1", "", "",
  "",
  15,TRICK_VOID, 0, 0, 0, Language_CPP, 0,
  0, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL} };

} //extern "C"


void init_attrSysSimObject() {

    static int initialized ;
    if (initialized) {
        return;
    }
    initialized = 1;

    trick_MM->add_attr_info(std::string(attrSysSimObject[0].type_name) , &attrSysSimObject[0], __FILE__ , __LINE__ ) ;
}

extern "C" {

void init_attrSysSimObject_c_intf() {
    init_attrSysSimObject() ;
}

size_t io_src_sizeof_SysSimObject() {
    return sizeof(SysSimObject) ;
}

void* io_src_allocate_SysSimObject(int num) {
    SysSimObject* temp = (SysSimObject*)calloc(num, sizeof(SysSimObject));
    for (int ii = 0; ii < num; ++ii) {
        new(&temp[ii]) SysSimObject();
    }
    return (void*)temp;
}

void io_src_destruct_SysSimObject(void* address __attribute__((unused)), int num __attribute__((unused))) {
SysSimObject* temp = (SysSimObject*)address;
    for (int ii = 0; ii < num; ++ii) {
        temp[ii].~SysSimObject();
    }
}

void io_src_delete_SysSimObject(void* address) {
    delete (SysSimObject*)address;
}

} //extern "C"

struct UnitsMapSysSimObject {
    UnitsMapSysSimObject() {
        Trick::UnitsMap* units_map_ptr = Trick::UnitsMap::units_map();
        units_map_ptr->add_param("SysSimObject_sched", "1") ;
    }
} umSysSimObject;

extern "C" {

ATTRIBUTES attrMonteCarloSimObject[] = {
{"mc", "Trick::MonteCarlo", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  120, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"", "", "1", "", "",
  "",
  15,TRICK_VOID, 0, 0, 0, Language_CPP, 0,
  0, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL} };

} //extern "C"


void init_attrMonteCarloSimObject() {

    static int initialized ;
    if (initialized) {
        return;
    }
    initialized = 1;

    trick_MM->add_attr_info(std::string(attrMonteCarloSimObject[0].type_name) , &attrMonteCarloSimObject[0], __FILE__ , __LINE__ ) ;
}

extern "C" {

void init_attrMonteCarloSimObject_c_intf() {
    init_attrMonteCarloSimObject() ;
}

size_t io_src_sizeof_MonteCarloSimObject() {
    return sizeof(MonteCarloSimObject) ;
}

void* io_src_allocate_MonteCarloSimObject(int num) {
    MonteCarloSimObject* temp = (MonteCarloSimObject*)calloc(num, sizeof(MonteCarloSimObject));
    for (int ii = 0; ii < num; ++ii) {
        new(&temp[ii]) MonteCarloSimObject();
    }
    return (void*)temp;
}

void io_src_destruct_MonteCarloSimObject(void* address __attribute__((unused)), int num __attribute__((unused))) {
MonteCarloSimObject* temp = (MonteCarloSimObject*)address;
    for (int ii = 0; ii < num; ++ii) {
        temp[ii].~MonteCarloSimObject();
    }
}

void io_src_delete_MonteCarloSimObject(void* address) {
    delete (MonteCarloSimObject*)address;
}

} //extern "C"

struct UnitsMapMonteCarloSimObject {
    UnitsMapMonteCarloSimObject() {
        Trick::UnitsMap* units_map_ptr = Trick::UnitsMap::units_map();
        units_map_ptr->add_param("MonteCarloSimObject_mc", "1") ;
    }
} umMonteCarloSimObject;

extern "C" {

ATTRIBUTES attrMemoryManagerSimObject[] = {
{"mm", "Trick::MemoryManager", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  120, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"", "", "1", "", "",
  "",
  15,TRICK_VOID, 0, 0, 0, Language_CPP, 0,
  0, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL} };

} //extern "C"


void init_attrMemoryManagerSimObject() {

    static int initialized ;
    if (initialized) {
        return;
    }
    initialized = 1;

    trick_MM->add_attr_info(std::string(attrMemoryManagerSimObject[0].type_name) , &attrMemoryManagerSimObject[0], __FILE__ , __LINE__ ) ;
}

extern "C" {

void init_attrMemoryManagerSimObject_c_intf() {
    init_attrMemoryManagerSimObject() ;
}

size_t io_src_sizeof_MemoryManagerSimObject() {
    return sizeof(MemoryManagerSimObject) ;
}

void* io_src_allocate_MemoryManagerSimObject(int num) {
    MemoryManagerSimObject* temp = (MemoryManagerSimObject*)calloc(num, sizeof(MemoryManagerSimObject));
    for (int ii = 0; ii < num; ++ii) {
        new(&temp[ii]) MemoryManagerSimObject();
    }
    return (void*)temp;
}

void io_src_destruct_MemoryManagerSimObject(void* address __attribute__((unused)), int num __attribute__((unused))) {
MemoryManagerSimObject* temp = (MemoryManagerSimObject*)address;
    for (int ii = 0; ii < num; ++ii) {
        temp[ii].~MemoryManagerSimObject();
    }
}

void io_src_delete_MemoryManagerSimObject(void* address) {
    delete (MemoryManagerSimObject*)address;
}

} //extern "C"

struct UnitsMapMemoryManagerSimObject {
    UnitsMapMemoryManagerSimObject() {
        Trick::UnitsMap* units_map_ptr = Trick::UnitsMap::units_map();
        units_map_ptr->add_param("MemoryManagerSimObject_mm", "1") ;
    }
} umMemoryManagerSimObject;

extern "C" {

ATTRIBUTES attrCheckPointRestartSimObject[] = {
{"cpr", "Trick::CheckPointRestart", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  120, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"", "", "1", "", "",
  "",
  15,TRICK_VOID, 0, 0, 0, Language_CPP, 0,
  0, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL} };

} //extern "C"


void init_attrCheckPointRestartSimObject() {

    static int initialized ;
    if (initialized) {
        return;
    }
    initialized = 1;

    trick_MM->add_attr_info(std::string(attrCheckPointRestartSimObject[0].type_name) , &attrCheckPointRestartSimObject[0], __FILE__ , __LINE__ ) ;
}

extern "C" {

void init_attrCheckPointRestartSimObject_c_intf() {
    init_attrCheckPointRestartSimObject() ;
}

size_t io_src_sizeof_CheckPointRestartSimObject() {
    return sizeof(CheckPointRestartSimObject) ;
}

void* io_src_allocate_CheckPointRestartSimObject(int num) {
    CheckPointRestartSimObject* temp = (CheckPointRestartSimObject*)calloc(num, sizeof(CheckPointRestartSimObject));
    for (int ii = 0; ii < num; ++ii) {
        new(&temp[ii]) CheckPointRestartSimObject();
    }
    return (void*)temp;
}

void io_src_destruct_CheckPointRestartSimObject(void* address __attribute__((unused)), int num __attribute__((unused))) {
CheckPointRestartSimObject* temp = (CheckPointRestartSimObject*)address;
    for (int ii = 0; ii < num; ++ii) {
        temp[ii].~CheckPointRestartSimObject();
    }
}

void io_src_delete_CheckPointRestartSimObject(void* address) {
    delete (CheckPointRestartSimObject*)address;
}

} //extern "C"

struct UnitsMapCheckPointRestartSimObject {
    UnitsMapCheckPointRestartSimObject() {
        Trick::UnitsMap* units_map_ptr = Trick::UnitsMap::units_map();
        units_map_ptr->add_param("CheckPointRestartSimObject_cpr", "1") ;
    }
} umCheckPointRestartSimObject;

extern "C" {

ATTRIBUTES attrSieSimObject[] = {
{"sie", "Trick::Sie", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  120, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"", "", "1", "", "",
  "",
  15,TRICK_VOID, 0, 0, 0, Language_CPP, 0,
  0, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL} };

} //extern "C"


void init_attrSieSimObject() {

    static int initialized ;
    if (initialized) {
        return;
    }
    initialized = 1;

    trick_MM->add_attr_info(std::string(attrSieSimObject[0].type_name) , &attrSieSimObject[0], __FILE__ , __LINE__ ) ;
}

extern "C" {

void init_attrSieSimObject_c_intf() {
    init_attrSieSimObject() ;
}

size_t io_src_sizeof_SieSimObject() {
    return sizeof(SieSimObject) ;
}

void* io_src_allocate_SieSimObject(int num) {
    SieSimObject* temp = (SieSimObject*)calloc(num, sizeof(SieSimObject));
    for (int ii = 0; ii < num; ++ii) {
        new(&temp[ii]) SieSimObject();
    }
    return (void*)temp;
}

void io_src_destruct_SieSimObject(void* address __attribute__((unused)), int num __attribute__((unused))) {
SieSimObject* temp = (SieSimObject*)address;
    for (int ii = 0; ii < num; ++ii) {
        temp[ii].~SieSimObject();
    }
}

void io_src_delete_SieSimObject(void* address) {
    delete (SieSimObject*)address;
}

} //extern "C"

struct UnitsMapSieSimObject {
    UnitsMapSieSimObject() {
        Trick::UnitsMap* units_map_ptr = Trick::UnitsMap::units_map();
        units_map_ptr->add_param("SieSimObject_sie", "1") ;
    }
} umSieSimObject;

extern "C" {

ATTRIBUTES attrCommandLineArgumentsSimObject[] = {
{"cmd_args", "Trick::CommandLineArguments", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  120, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"", "", "1", "", "",
  "",
  15,TRICK_VOID, 0, 0, 0, Language_CPP, 0,
  0, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL} };

} //extern "C"


void init_attrCommandLineArgumentsSimObject() {

    static int initialized ;
    if (initialized) {
        return;
    }
    initialized = 1;

    trick_MM->add_attr_info(std::string(attrCommandLineArgumentsSimObject[0].type_name) , &attrCommandLineArgumentsSimObject[0], __FILE__ , __LINE__ ) ;
}

extern "C" {

void init_attrCommandLineArgumentsSimObject_c_intf() {
    init_attrCommandLineArgumentsSimObject() ;
}

size_t io_src_sizeof_CommandLineArgumentsSimObject() {
    return sizeof(CommandLineArgumentsSimObject) ;
}

void* io_src_allocate_CommandLineArgumentsSimObject(int num) {
    CommandLineArgumentsSimObject* temp = (CommandLineArgumentsSimObject*)calloc(num, sizeof(CommandLineArgumentsSimObject));
    for (int ii = 0; ii < num; ++ii) {
        new(&temp[ii]) CommandLineArgumentsSimObject();
    }
    return (void*)temp;
}

void io_src_destruct_CommandLineArgumentsSimObject(void* address __attribute__((unused)), int num __attribute__((unused))) {
CommandLineArgumentsSimObject* temp = (CommandLineArgumentsSimObject*)address;
    for (int ii = 0; ii < num; ++ii) {
        temp[ii].~CommandLineArgumentsSimObject();
    }
}

void io_src_delete_CommandLineArgumentsSimObject(void* address) {
    delete (CommandLineArgumentsSimObject*)address;
}

} //extern "C"

struct UnitsMapCommandLineArgumentsSimObject {
    UnitsMapCommandLineArgumentsSimObject() {
        Trick::UnitsMap* units_map_ptr = Trick::UnitsMap::units_map();
        units_map_ptr->add_param("CommandLineArgumentsSimObject_cmd_args", "1") ;
    }
} umCommandLineArgumentsSimObject;

extern "C" {

ATTRIBUTES attrMessageSimObject[] = {
{"mpublisher", "Trick::MessagePublisher", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  120, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"mcout", "Trick::MessageCout", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  248, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"mtcout", "Trick::MessageThreadedCout", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  296, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"mfile", "Trick::MessageFile", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  520, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"mdevice", "Trick::MessageTCDevice", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  1128, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"pfile", "Trick::PlaybackFile", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  1496, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"", "", "1", "", "",
  "",
  15,TRICK_VOID, 0, 0, 0, Language_CPP, 0,
  0, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL} };

} //extern "C"


void init_attrMessageSimObject() {

    static int initialized ;
    if (initialized) {
        return;
    }
    initialized = 1;

    trick_MM->add_attr_info(std::string(attrMessageSimObject[0].type_name) , &attrMessageSimObject[0], __FILE__ , __LINE__ ) ;
    trick_MM->add_attr_info(std::string(attrMessageSimObject[1].type_name) , &attrMessageSimObject[1], __FILE__ , __LINE__ ) ;
    trick_MM->add_attr_info(std::string(attrMessageSimObject[2].type_name) , &attrMessageSimObject[2], __FILE__ , __LINE__ ) ;
    trick_MM->add_attr_info(std::string(attrMessageSimObject[3].type_name) , &attrMessageSimObject[3], __FILE__ , __LINE__ ) ;
    trick_MM->add_attr_info(std::string(attrMessageSimObject[4].type_name) , &attrMessageSimObject[4], __FILE__ , __LINE__ ) ;
    trick_MM->add_attr_info(std::string(attrMessageSimObject[5].type_name) , &attrMessageSimObject[5], __FILE__ , __LINE__ ) ;
}

extern "C" {

void init_attrMessageSimObject_c_intf() {
    init_attrMessageSimObject() ;
}

size_t io_src_sizeof_MessageSimObject() {
    return sizeof(MessageSimObject) ;
}

void* io_src_allocate_MessageSimObject(int num) {
    MessageSimObject* temp = (MessageSimObject*)calloc(num, sizeof(MessageSimObject));
    for (int ii = 0; ii < num; ++ii) {
        new(&temp[ii]) MessageSimObject();
    }
    return (void*)temp;
}

void io_src_destruct_MessageSimObject(void* address __attribute__((unused)), int num __attribute__((unused))) {
MessageSimObject* temp = (MessageSimObject*)address;
    for (int ii = 0; ii < num; ++ii) {
        temp[ii].~MessageSimObject();
    }
}

void io_src_delete_MessageSimObject(void* address) {
    delete (MessageSimObject*)address;
}

} //extern "C"

struct UnitsMapMessageSimObject {
    UnitsMapMessageSimObject() {
        Trick::UnitsMap* units_map_ptr = Trick::UnitsMap::units_map();
        units_map_ptr->add_param("MessageSimObject_mpublisher", "1") ;
        units_map_ptr->add_param("MessageSimObject_mcout", "1") ;
        units_map_ptr->add_param("MessageSimObject_mtcout", "1") ;
        units_map_ptr->add_param("MessageSimObject_mfile", "1") ;
        units_map_ptr->add_param("MessageSimObject_mdevice", "1") ;
        units_map_ptr->add_param("MessageSimObject_pfile", "1") ;
    }
} umMessageSimObject;

extern "C" {

ATTRIBUTES attrJITSimObject[] = {
{"jit", "Trick::JITInputFile", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  120, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"", "", "1", "", "",
  "",
  15,TRICK_VOID, 0, 0, 0, Language_CPP, 0,
  0, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL} };

} //extern "C"


void init_attrJITSimObject() {

    static int initialized ;
    if (initialized) {
        return;
    }
    initialized = 1;

    trick_MM->add_attr_info(std::string(attrJITSimObject[0].type_name) , &attrJITSimObject[0], __FILE__ , __LINE__ ) ;
}

extern "C" {

void init_attrJITSimObject_c_intf() {
    init_attrJITSimObject() ;
}

size_t io_src_sizeof_JITSimObject() {
    return sizeof(JITSimObject) ;
}

void* io_src_allocate_JITSimObject(int num) {
    JITSimObject* temp = (JITSimObject*)calloc(num, sizeof(JITSimObject));
    for (int ii = 0; ii < num; ++ii) {
        new(&temp[ii]) JITSimObject();
    }
    return (void*)temp;
}

void io_src_destruct_JITSimObject(void* address __attribute__((unused)), int num __attribute__((unused))) {
JITSimObject* temp = (JITSimObject*)address;
    for (int ii = 0; ii < num; ++ii) {
        temp[ii].~JITSimObject();
    }
}

void io_src_delete_JITSimObject(void* address) {
    delete (JITSimObject*)address;
}

} //extern "C"

struct UnitsMapJITSimObject {
    UnitsMapJITSimObject() {
        Trick::UnitsMap* units_map_ptr = Trick::UnitsMap::units_map();
        units_map_ptr->add_param("JITSimObject_jit", "1") ;
    }
} umJITSimObject;

extern "C" {

ATTRIBUTES attrInputProcessorSimObject[] = {
{"ip", "Trick::IPPython", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  120, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"mtv", "Trick::MTV", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  224, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"", "", "1", "", "",
  "",
  15,TRICK_VOID, 0, 0, 0, Language_CPP, 0,
  0, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL} };

} //extern "C"


void init_attrInputProcessorSimObject() {

    static int initialized ;
    if (initialized) {
        return;
    }
    initialized = 1;

    trick_MM->add_attr_info(std::string(attrInputProcessorSimObject[0].type_name) , &attrInputProcessorSimObject[0], __FILE__ , __LINE__ ) ;
    trick_MM->add_attr_info(std::string(attrInputProcessorSimObject[1].type_name) , &attrInputProcessorSimObject[1], __FILE__ , __LINE__ ) ;
}

extern "C" {

void init_attrInputProcessorSimObject_c_intf() {
    init_attrInputProcessorSimObject() ;
}

size_t io_src_sizeof_InputProcessorSimObject() {
    return sizeof(InputProcessorSimObject) ;
}

void* io_src_allocate_InputProcessorSimObject(int num) {
    InputProcessorSimObject* temp = (InputProcessorSimObject*)calloc(num, sizeof(InputProcessorSimObject));
    for (int ii = 0; ii < num; ++ii) {
        new(&temp[ii]) InputProcessorSimObject();
    }
    return (void*)temp;
}

void io_src_destruct_InputProcessorSimObject(void* address __attribute__((unused)), int num __attribute__((unused))) {
InputProcessorSimObject* temp = (InputProcessorSimObject*)address;
    for (int ii = 0; ii < num; ++ii) {
        temp[ii].~InputProcessorSimObject();
    }
}

void io_src_delete_InputProcessorSimObject(void* address) {
    delete (InputProcessorSimObject*)address;
}

} //extern "C"

struct UnitsMapInputProcessorSimObject {
    UnitsMapInputProcessorSimObject() {
        Trick::UnitsMap* units_map_ptr = Trick::UnitsMap::units_map();
        units_map_ptr->add_param("InputProcessorSimObject_ip", "1") ;
        units_map_ptr->add_param("InputProcessorSimObject_mtv", "1") ;
    }
} umInputProcessorSimObject;

extern "C" {

ATTRIBUTES attrThreadProcessEventSimObject[] = {
{"ep", "Trick::EventProcessor", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  120, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"", "", "1", "", "",
  "",
  15,TRICK_VOID, 0, 0, 0, Language_CPP, 0,
  0, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL} };

} //extern "C"


void init_attrThreadProcessEventSimObject() {

    static int initialized ;
    if (initialized) {
        return;
    }
    initialized = 1;

    trick_MM->add_attr_info(std::string(attrThreadProcessEventSimObject[0].type_name) , &attrThreadProcessEventSimObject[0], __FILE__ , __LINE__ ) ;
}

extern "C" {

void init_attrThreadProcessEventSimObject_c_intf() {
    init_attrThreadProcessEventSimObject() ;
}

size_t io_src_sizeof_ThreadProcessEventSimObject() {
    return sizeof(ThreadProcessEventSimObject) ;
}

void io_src_destruct_ThreadProcessEventSimObject(void* address __attribute__((unused)), int num __attribute__((unused))) {
ThreadProcessEventSimObject* temp = (ThreadProcessEventSimObject*)address;
    for (int ii = 0; ii < num; ++ii) {
        temp[ii].~ThreadProcessEventSimObject();
    }
}

void io_src_delete_ThreadProcessEventSimObject(void* address) {
    delete (ThreadProcessEventSimObject*)address;
}

} //extern "C"

struct UnitsMapThreadProcessEventSimObject {
    UnitsMapThreadProcessEventSimObject() {
        Trick::UnitsMap* units_map_ptr = Trick::UnitsMap::units_map();
        units_map_ptr->add_param("ThreadProcessEventSimObject_ep", "1") ;
    }
} umThreadProcessEventSimObject;

extern "C" {

ATTRIBUTES attrEventManagerSimObject[] = {
{"em", "Trick::EventManager", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  120, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"ep", "Trick::EventProcessor", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  184, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"", "", "1", "", "",
  "",
  15,TRICK_VOID, 0, 0, 0, Language_CPP, 0,
  0, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL} };

} //extern "C"


void init_attrEventManagerSimObject() {

    static int initialized ;
    if (initialized) {
        return;
    }
    initialized = 1;

    trick_MM->add_attr_info(std::string(attrEventManagerSimObject[0].type_name) , &attrEventManagerSimObject[0], __FILE__ , __LINE__ ) ;
    trick_MM->add_attr_info(std::string(attrEventManagerSimObject[1].type_name) , &attrEventManagerSimObject[1], __FILE__ , __LINE__ ) ;
}

extern "C" {

void init_attrEventManagerSimObject_c_intf() {
    init_attrEventManagerSimObject() ;
}

size_t io_src_sizeof_EventManagerSimObject() {
    return sizeof(EventManagerSimObject) ;
}

void* io_src_allocate_EventManagerSimObject(int num) {
    EventManagerSimObject* temp = (EventManagerSimObject*)calloc(num, sizeof(EventManagerSimObject));
    for (int ii = 0; ii < num; ++ii) {
        new(&temp[ii]) EventManagerSimObject();
    }
    return (void*)temp;
}

void io_src_destruct_EventManagerSimObject(void* address __attribute__((unused)), int num __attribute__((unused))) {
EventManagerSimObject* temp = (EventManagerSimObject*)address;
    for (int ii = 0; ii < num; ++ii) {
        temp[ii].~EventManagerSimObject();
    }
}

void io_src_delete_EventManagerSimObject(void* address) {
    delete (EventManagerSimObject*)address;
}

} //extern "C"

struct UnitsMapEventManagerSimObject {
    UnitsMapEventManagerSimObject() {
        Trick::UnitsMap* units_map_ptr = Trick::UnitsMap::units_map();
        units_map_ptr->add_param("EventManagerSimObject_em", "1") ;
        units_map_ptr->add_param("EventManagerSimObject_ep", "1") ;
    }
} umEventManagerSimObject;

extern "C" {

ATTRIBUTES attrVariableServerSimObject[] = {
{"vs", "Trick::VariableServer", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  120, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"sim_control_panel", "Trick::SimControlPanel", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  720, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"trick_view", "Trick::TrickView", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  1256, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"malfunctions_trick_view", "Trick::MalfunctionsTrickView", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  1912, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"stripchart", "Trick::StripChart", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  2448, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"monte_monitor", "Trick::MonteMonitor", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  3024, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"", "", "1", "", "",
  "",
  15,TRICK_VOID, 0, 0, 0, Language_CPP, 0,
  0, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL} };

} //extern "C"


void init_attrVariableServerSimObject() {

    static int initialized ;
    if (initialized) {
        return;
    }
    initialized = 1;

    trick_MM->add_attr_info(std::string(attrVariableServerSimObject[0].type_name) , &attrVariableServerSimObject[0], __FILE__ , __LINE__ ) ;
    trick_MM->add_attr_info(std::string(attrVariableServerSimObject[1].type_name) , &attrVariableServerSimObject[1], __FILE__ , __LINE__ ) ;
    trick_MM->add_attr_info(std::string(attrVariableServerSimObject[2].type_name) , &attrVariableServerSimObject[2], __FILE__ , __LINE__ ) ;
    trick_MM->add_attr_info(std::string(attrVariableServerSimObject[3].type_name) , &attrVariableServerSimObject[3], __FILE__ , __LINE__ ) ;
    trick_MM->add_attr_info(std::string(attrVariableServerSimObject[4].type_name) , &attrVariableServerSimObject[4], __FILE__ , __LINE__ ) ;
    trick_MM->add_attr_info(std::string(attrVariableServerSimObject[5].type_name) , &attrVariableServerSimObject[5], __FILE__ , __LINE__ ) ;
}

extern "C" {

void init_attrVariableServerSimObject_c_intf() {
    init_attrVariableServerSimObject() ;
}

size_t io_src_sizeof_VariableServerSimObject() {
    return sizeof(VariableServerSimObject) ;
}

void* io_src_allocate_VariableServerSimObject(int num) {
    VariableServerSimObject* temp = (VariableServerSimObject*)calloc(num, sizeof(VariableServerSimObject));
    for (int ii = 0; ii < num; ++ii) {
        new(&temp[ii]) VariableServerSimObject();
    }
    return (void*)temp;
}

void io_src_destruct_VariableServerSimObject(void* address __attribute__((unused)), int num __attribute__((unused))) {
VariableServerSimObject* temp = (VariableServerSimObject*)address;
    for (int ii = 0; ii < num; ++ii) {
        temp[ii].~VariableServerSimObject();
    }
}

void io_src_delete_VariableServerSimObject(void* address) {
    delete (VariableServerSimObject*)address;
}

} //extern "C"

struct UnitsMapVariableServerSimObject {
    UnitsMapVariableServerSimObject() {
        Trick::UnitsMap* units_map_ptr = Trick::UnitsMap::units_map();
        units_map_ptr->add_param("VariableServerSimObject_vs", "1") ;
        units_map_ptr->add_param("VariableServerSimObject_sim_control_panel", "1") ;
        units_map_ptr->add_param("VariableServerSimObject_trick_view", "1") ;
        units_map_ptr->add_param("VariableServerSimObject_malfunctions_trick_view", "1") ;
        units_map_ptr->add_param("VariableServerSimObject_stripchart", "1") ;
        units_map_ptr->add_param("VariableServerSimObject_monte_monitor", "1") ;
    }
} umVariableServerSimObject;

extern "C" {

ATTRIBUTES attrDataRecordDispatcherSimObject[] = {
{"drd", "Trick::DataRecordDispatcher", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  120, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"", "", "1", "", "",
  "",
  15,TRICK_VOID, 0, 0, 0, Language_CPP, 0,
  0, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL} };

} //extern "C"


void init_attrDataRecordDispatcherSimObject() {

    static int initialized ;
    if (initialized) {
        return;
    }
    initialized = 1;

    trick_MM->add_attr_info(std::string(attrDataRecordDispatcherSimObject[0].type_name) , &attrDataRecordDispatcherSimObject[0], __FILE__ , __LINE__ ) ;
}

extern "C" {

void init_attrDataRecordDispatcherSimObject_c_intf() {
    init_attrDataRecordDispatcherSimObject() ;
}

size_t io_src_sizeof_DataRecordDispatcherSimObject() {
    return sizeof(DataRecordDispatcherSimObject) ;
}

void* io_src_allocate_DataRecordDispatcherSimObject(int num) {
    DataRecordDispatcherSimObject* temp = (DataRecordDispatcherSimObject*)calloc(num, sizeof(DataRecordDispatcherSimObject));
    for (int ii = 0; ii < num; ++ii) {
        new(&temp[ii]) DataRecordDispatcherSimObject();
    }
    return (void*)temp;
}

void io_src_destruct_DataRecordDispatcherSimObject(void* address __attribute__((unused)), int num __attribute__((unused))) {
DataRecordDispatcherSimObject* temp = (DataRecordDispatcherSimObject*)address;
    for (int ii = 0; ii < num; ++ii) {
        temp[ii].~DataRecordDispatcherSimObject();
    }
}

void io_src_delete_DataRecordDispatcherSimObject(void* address) {
    delete (DataRecordDispatcherSimObject*)address;
}

} //extern "C"

struct UnitsMapDataRecordDispatcherSimObject {
    UnitsMapDataRecordDispatcherSimObject() {
        Trick::UnitsMap* units_map_ptr = Trick::UnitsMap::units_map();
        units_map_ptr->add_param("DataRecordDispatcherSimObject_drd", "1") ;
    }
} umDataRecordDispatcherSimObject;

extern "C" {

ATTRIBUTES attrRTSyncSimObject[] = {
{"gtod_clock", "Trick::GetTimeOfDayClock", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  120, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"itimer", "Trick::ITimer", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  200, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"rt_sync", "Trick::RealtimeSync", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  288, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"", "", "1", "", "",
  "",
  15,TRICK_VOID, 0, 0, 0, Language_CPP, 0,
  0, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL} };

} //extern "C"


void init_attrRTSyncSimObject() {

    static int initialized ;
    if (initialized) {
        return;
    }
    initialized = 1;

    trick_MM->add_attr_info(std::string(attrRTSyncSimObject[0].type_name) , &attrRTSyncSimObject[0], __FILE__ , __LINE__ ) ;
    trick_MM->add_attr_info(std::string(attrRTSyncSimObject[1].type_name) , &attrRTSyncSimObject[1], __FILE__ , __LINE__ ) ;
    trick_MM->add_attr_info(std::string(attrRTSyncSimObject[2].type_name) , &attrRTSyncSimObject[2], __FILE__ , __LINE__ ) ;
}

extern "C" {

void init_attrRTSyncSimObject_c_intf() {
    init_attrRTSyncSimObject() ;
}

size_t io_src_sizeof_RTSyncSimObject() {
    return sizeof(RTSyncSimObject) ;
}

void* io_src_allocate_RTSyncSimObject(int num) {
    RTSyncSimObject* temp = (RTSyncSimObject*)calloc(num, sizeof(RTSyncSimObject));
    for (int ii = 0; ii < num; ++ii) {
        new(&temp[ii]) RTSyncSimObject();
    }
    return (void*)temp;
}

void io_src_destruct_RTSyncSimObject(void* address __attribute__((unused)), int num __attribute__((unused))) {
RTSyncSimObject* temp = (RTSyncSimObject*)address;
    for (int ii = 0; ii < num; ++ii) {
        temp[ii].~RTSyncSimObject();
    }
}

void io_src_delete_RTSyncSimObject(void* address) {
    delete (RTSyncSimObject*)address;
}

} //extern "C"

struct UnitsMapRTSyncSimObject {
    UnitsMapRTSyncSimObject() {
        Trick::UnitsMap* units_map_ptr = Trick::UnitsMap::units_map();
        units_map_ptr->add_param("RTSyncSimObject_gtod_clock", "1") ;
        units_map_ptr->add_param("RTSyncSimObject_itimer", "1") ;
        units_map_ptr->add_param("RTSyncSimObject_rt_sync", "1") ;
    }
} umRTSyncSimObject;

extern "C" {

ATTRIBUTES attrFrameLogSimObject[] = {
{"frame_log", "Trick::FrameLog", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  120, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"", "", "1", "", "",
  "",
  15,TRICK_VOID, 0, 0, 0, Language_CPP, 0,
  0, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL} };

} //extern "C"


void init_attrFrameLogSimObject() {

    static int initialized ;
    if (initialized) {
        return;
    }
    initialized = 1;

    trick_MM->add_attr_info(std::string(attrFrameLogSimObject[0].type_name) , &attrFrameLogSimObject[0], __FILE__ , __LINE__ ) ;
}

extern "C" {

void init_attrFrameLogSimObject_c_intf() {
    init_attrFrameLogSimObject() ;
}

size_t io_src_sizeof_FrameLogSimObject() {
    return sizeof(FrameLogSimObject) ;
}

void io_src_destruct_FrameLogSimObject(void* address __attribute__((unused)), int num __attribute__((unused))) {
FrameLogSimObject* temp = (FrameLogSimObject*)address;
    for (int ii = 0; ii < num; ++ii) {
        temp[ii].~FrameLogSimObject();
    }
}

void io_src_delete_FrameLogSimObject(void* address) {
    delete (FrameLogSimObject*)address;
}

} //extern "C"

struct UnitsMapFrameLogSimObject {
    UnitsMapFrameLogSimObject() {
        Trick::UnitsMap* units_map_ptr = Trick::UnitsMap::units_map();
        units_map_ptr->add_param("FrameLogSimObject_frame_log", "1") ;
    }
} umFrameLogSimObject;

extern "C" {

ATTRIBUTES attrMasterSlaveSimObject[] = {
{"master", "Trick::Master", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  120, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"slave", "Trick::Slave", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  152, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"", "", "1", "", "",
  "",
  15,TRICK_VOID, 0, 0, 0, Language_CPP, 0,
  0, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL} };

} //extern "C"


void init_attrMasterSlaveSimObject() {

    static int initialized ;
    if (initialized) {
        return;
    }
    initialized = 1;

    trick_MM->add_attr_info(std::string(attrMasterSlaveSimObject[0].type_name) , &attrMasterSlaveSimObject[0], __FILE__ , __LINE__ ) ;
    trick_MM->add_attr_info(std::string(attrMasterSlaveSimObject[1].type_name) , &attrMasterSlaveSimObject[1], __FILE__ , __LINE__ ) ;
}

extern "C" {

void init_attrMasterSlaveSimObject_c_intf() {
    init_attrMasterSlaveSimObject() ;
}

size_t io_src_sizeof_MasterSlaveSimObject() {
    return sizeof(MasterSlaveSimObject) ;
}

void* io_src_allocate_MasterSlaveSimObject(int num) {
    MasterSlaveSimObject* temp = (MasterSlaveSimObject*)calloc(num, sizeof(MasterSlaveSimObject));
    for (int ii = 0; ii < num; ++ii) {
        new(&temp[ii]) MasterSlaveSimObject();
    }
    return (void*)temp;
}

void io_src_destruct_MasterSlaveSimObject(void* address __attribute__((unused)), int num __attribute__((unused))) {
MasterSlaveSimObject* temp = (MasterSlaveSimObject*)address;
    for (int ii = 0; ii < num; ++ii) {
        temp[ii].~MasterSlaveSimObject();
    }
}

void io_src_delete_MasterSlaveSimObject(void* address) {
    delete (MasterSlaveSimObject*)address;
}

} //extern "C"

struct UnitsMapMasterSlaveSimObject {
    UnitsMapMasterSlaveSimObject() {
        Trick::UnitsMap* units_map_ptr = Trick::UnitsMap::units_map();
        units_map_ptr->add_param("MasterSlaveSimObject_master", "1") ;
        units_map_ptr->add_param("MasterSlaveSimObject_slave", "1") ;
    }
} umMasterSlaveSimObject;

extern "C" {

ATTRIBUTES attrInstrumentationSimObject[] = {
{"echo_jobs", "Trick::EchoJobs", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  120, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"debug_pause", "Trick::DebugPause", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  128, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"", "", "1", "", "",
  "",
  15,TRICK_VOID, 0, 0, 0, Language_CPP, 0,
  0, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL} };

} //extern "C"


void init_attrInstrumentationSimObject() {

    static int initialized ;
    if (initialized) {
        return;
    }
    initialized = 1;

    trick_MM->add_attr_info(std::string(attrInstrumentationSimObject[0].type_name) , &attrInstrumentationSimObject[0], __FILE__ , __LINE__ ) ;
    trick_MM->add_attr_info(std::string(attrInstrumentationSimObject[1].type_name) , &attrInstrumentationSimObject[1], __FILE__ , __LINE__ ) ;
}

extern "C" {

void init_attrInstrumentationSimObject_c_intf() {
    init_attrInstrumentationSimObject() ;
}

size_t io_src_sizeof_InstrumentationSimObject() {
    return sizeof(InstrumentationSimObject) ;
}

void* io_src_allocate_InstrumentationSimObject(int num) {
    InstrumentationSimObject* temp = (InstrumentationSimObject*)calloc(num, sizeof(InstrumentationSimObject));
    for (int ii = 0; ii < num; ++ii) {
        new(&temp[ii]) InstrumentationSimObject();
    }
    return (void*)temp;
}

void io_src_destruct_InstrumentationSimObject(void* address __attribute__((unused)), int num __attribute__((unused))) {
InstrumentationSimObject* temp = (InstrumentationSimObject*)address;
    for (int ii = 0; ii < num; ++ii) {
        temp[ii].~InstrumentationSimObject();
    }
}

void io_src_delete_InstrumentationSimObject(void* address) {
    delete (InstrumentationSimObject*)address;
}

} //extern "C"

struct UnitsMapInstrumentationSimObject {
    UnitsMapInstrumentationSimObject() {
        Trick::UnitsMap* units_map_ptr = Trick::UnitsMap::units_map();
        units_map_ptr->add_param("InstrumentationSimObject_echo_jobs", "1") ;
        units_map_ptr->add_param("InstrumentationSimObject_debug_pause", "1") ;
    }
} umInstrumentationSimObject;

extern "C" {

ATTRIBUTES attrDMTCPSimObject[] = {
{"dmtcp", "Trick::DMTCP", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  120, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"", "", "1", "", "",
  "",
  15,TRICK_VOID, 0, 0, 0, Language_CPP, 0,
  0, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL} };

} //extern "C"


void init_attrDMTCPSimObject() {

    static int initialized ;
    if (initialized) {
        return;
    }
    initialized = 1;

    trick_MM->add_attr_info(std::string(attrDMTCPSimObject[0].type_name) , &attrDMTCPSimObject[0], __FILE__ , __LINE__ ) ;
}

extern "C" {

void init_attrDMTCPSimObject_c_intf() {
    init_attrDMTCPSimObject() ;
}

size_t io_src_sizeof_DMTCPSimObject() {
    return sizeof(DMTCPSimObject) ;
}

void* io_src_allocate_DMTCPSimObject(int num) {
    DMTCPSimObject* temp = (DMTCPSimObject*)calloc(num, sizeof(DMTCPSimObject));
    for (int ii = 0; ii < num; ++ii) {
        new(&temp[ii]) DMTCPSimObject();
    }
    return (void*)temp;
}

void io_src_destruct_DMTCPSimObject(void* address __attribute__((unused)), int num __attribute__((unused))) {
DMTCPSimObject* temp = (DMTCPSimObject*)address;
    for (int ii = 0; ii < num; ++ii) {
        temp[ii].~DMTCPSimObject();
    }
}

void io_src_delete_DMTCPSimObject(void* address) {
    delete (DMTCPSimObject*)address;
}

} //extern "C"

struct UnitsMapDMTCPSimObject {
    UnitsMapDMTCPSimObject() {
        Trick::UnitsMap* units_map_ptr = Trick::UnitsMap::units_map();
        units_map_ptr->add_param("DMTCPSimObject_dmtcp", "1") ;
    }
} umDMTCPSimObject;

extern "C" {

ATTRIBUTES attrInjectorExecSimObject[] = {
{"rtie", "Trick::RtiExec", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  120, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"", "", "1", "", "",
  "",
  15,TRICK_VOID, 0, 0, 0, Language_CPP, 0,
  0, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL} };

} //extern "C"


void init_attrInjectorExecSimObject() {

    static int initialized ;
    if (initialized) {
        return;
    }
    initialized = 1;

    trick_MM->add_attr_info(std::string(attrInjectorExecSimObject[0].type_name) , &attrInjectorExecSimObject[0], __FILE__ , __LINE__ ) ;
}

extern "C" {

void init_attrInjectorExecSimObject_c_intf() {
    init_attrInjectorExecSimObject() ;
}

size_t io_src_sizeof_InjectorExecSimObject() {
    return sizeof(InjectorExecSimObject) ;
}

void io_src_destruct_InjectorExecSimObject(void* address __attribute__((unused)), int num __attribute__((unused))) {
InjectorExecSimObject* temp = (InjectorExecSimObject*)address;
    for (int ii = 0; ii < num; ++ii) {
        temp[ii].~InjectorExecSimObject();
    }
}

void io_src_delete_InjectorExecSimObject(void* address) {
    delete (InjectorExecSimObject*)address;
}

} //extern "C"

struct UnitsMapInjectorExecSimObject {
    UnitsMapInjectorExecSimObject() {
        Trick::UnitsMap* units_map_ptr = Trick::UnitsMap::units_map();
        units_map_ptr->add_param("InjectorExecSimObject_rtie", "1") ;
    }
} umInjectorExecSimObject;

extern "C" {

ATTRIBUTES attrInjectorSimObject[] = {
{"rtis", "Trick::RtiStager", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  120, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"", "", "1", "", "",
  "",
  15,TRICK_VOID, 0, 0, 0, Language_CPP, 0,
  0, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL} };

} //extern "C"


void init_attrInjectorSimObject() {

    static int initialized ;
    if (initialized) {
        return;
    }
    initialized = 1;

    trick_MM->add_attr_info(std::string(attrInjectorSimObject[0].type_name) , &attrInjectorSimObject[0], __FILE__ , __LINE__ ) ;
}

extern "C" {

void init_attrInjectorSimObject_c_intf() {
    init_attrInjectorSimObject() ;
}

size_t io_src_sizeof_InjectorSimObject() {
    return sizeof(InjectorSimObject) ;
}

void* io_src_allocate_InjectorSimObject(int num) {
    InjectorSimObject* temp = (InjectorSimObject*)calloc(num, sizeof(InjectorSimObject));
    for (int ii = 0; ii < num; ++ii) {
        new(&temp[ii]) InjectorSimObject();
    }
    return (void*)temp;
}

void io_src_destruct_InjectorSimObject(void* address __attribute__((unused)), int num __attribute__((unused))) {
InjectorSimObject* temp = (InjectorSimObject*)address;
    for (int ii = 0; ii < num; ++ii) {
        temp[ii].~InjectorSimObject();
    }
}

void io_src_delete_InjectorSimObject(void* address) {
    delete (InjectorSimObject*)address;
}

} //extern "C"

struct UnitsMapInjectorSimObject {
    UnitsMapInjectorSimObject() {
        Trick::UnitsMap* units_map_ptr = Trick::UnitsMap::units_map();
        units_map_ptr->add_param("InjectorSimObject_rtis", "1") ;
    }
} umInjectorSimObject;

extern "C" {

ATTRIBUTES attrZeroconfSimObject[] = {
{"zc", "Trick::Zeroconf", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  120, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"", "", "1", "", "",
  "",
  15,TRICK_VOID, 0, 0, 0, Language_CPP, 0,
  0, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL} };

} //extern "C"


void init_attrZeroconfSimObject() {

    static int initialized ;
    if (initialized) {
        return;
    }
    initialized = 1;

    trick_MM->add_attr_info(std::string(attrZeroconfSimObject[0].type_name) , &attrZeroconfSimObject[0], __FILE__ , __LINE__ ) ;
}

extern "C" {

void init_attrZeroconfSimObject_c_intf() {
    init_attrZeroconfSimObject() ;
}

size_t io_src_sizeof_ZeroconfSimObject() {
    return sizeof(ZeroconfSimObject) ;
}

void* io_src_allocate_ZeroconfSimObject(int num) {
    ZeroconfSimObject* temp = (ZeroconfSimObject*)calloc(num, sizeof(ZeroconfSimObject));
    for (int ii = 0; ii < num; ++ii) {
        new(&temp[ii]) ZeroconfSimObject();
    }
    return (void*)temp;
}

void io_src_destruct_ZeroconfSimObject(void* address __attribute__((unused)), int num __attribute__((unused))) {
ZeroconfSimObject* temp = (ZeroconfSimObject*)address;
    for (int ii = 0; ii < num; ++ii) {
        temp[ii].~ZeroconfSimObject();
    }
}

void io_src_delete_ZeroconfSimObject(void* address) {
    delete (ZeroconfSimObject*)address;
}

} //extern "C"

struct UnitsMapZeroconfSimObject {
    UnitsMapZeroconfSimObject() {
        Trick::UnitsMap* units_map_ptr = Trick::UnitsMap::units_map();
        units_map_ptr->add_param("ZeroconfSimObject_zc", "1") ;
    }
} umZeroconfSimObject;

extern "C" {

ATTRIBUTES attrUnitTestSimObject[] = {
{"unit_tests", "Trick::UnitTest", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  120, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"", "", "1", "", "",
  "",
  15,TRICK_VOID, 0, 0, 0, Language_CPP, 0,
  0, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL} };

} //extern "C"


void init_attrUnitTestSimObject() {

    static int initialized ;
    if (initialized) {
        return;
    }
    initialized = 1;

    trick_MM->add_attr_info(std::string(attrUnitTestSimObject[0].type_name) , &attrUnitTestSimObject[0], __FILE__ , __LINE__ ) ;
}

extern "C" {

void init_attrUnitTestSimObject_c_intf() {
    init_attrUnitTestSimObject() ;
}

size_t io_src_sizeof_UnitTestSimObject() {
    return sizeof(UnitTestSimObject) ;
}

void* io_src_allocate_UnitTestSimObject(int num) {
    UnitTestSimObject* temp = (UnitTestSimObject*)calloc(num, sizeof(UnitTestSimObject));
    for (int ii = 0; ii < num; ++ii) {
        new(&temp[ii]) UnitTestSimObject();
    }
    return (void*)temp;
}

void io_src_destruct_UnitTestSimObject(void* address __attribute__((unused)), int num __attribute__((unused))) {
UnitTestSimObject* temp = (UnitTestSimObject*)address;
    for (int ii = 0; ii < num; ++ii) {
        temp[ii].~UnitTestSimObject();
    }
}

void io_src_delete_UnitTestSimObject(void* address) {
    delete (UnitTestSimObject*)address;
}

} //extern "C"

struct UnitsMapUnitTestSimObject {
    UnitsMapUnitTestSimObject() {
        Trick::UnitsMap* units_map_ptr = Trick::UnitsMap::units_map();
        units_map_ptr->add_param("UnitTestSimObject_unit_tests", "1") ;
    }
} umUnitTestSimObject;

extern "C" {

ATTRIBUTES attrUdUnitsSimObject[] = {
{"udunits", "Trick::UdUnits", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  120, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"", "", "1", "", "",
  "",
  15,TRICK_VOID, 0, 0, 0, Language_CPP, 0,
  0, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL} };

} //extern "C"


void init_attrUdUnitsSimObject() {

    static int initialized ;
    if (initialized) {
        return;
    }
    initialized = 1;

    trick_MM->add_attr_info(std::string(attrUdUnitsSimObject[0].type_name) , &attrUdUnitsSimObject[0], __FILE__ , __LINE__ ) ;
}

extern "C" {

void init_attrUdUnitsSimObject_c_intf() {
    init_attrUdUnitsSimObject() ;
}

size_t io_src_sizeof_UdUnitsSimObject() {
    return sizeof(UdUnitsSimObject) ;
}

void* io_src_allocate_UdUnitsSimObject(int num) {
    UdUnitsSimObject* temp = (UdUnitsSimObject*)calloc(num, sizeof(UdUnitsSimObject));
    for (int ii = 0; ii < num; ++ii) {
        new(&temp[ii]) UdUnitsSimObject();
    }
    return (void*)temp;
}

void io_src_destruct_UdUnitsSimObject(void* address __attribute__((unused)), int num __attribute__((unused))) {
UdUnitsSimObject* temp = (UdUnitsSimObject*)address;
    for (int ii = 0; ii < num; ++ii) {
        temp[ii].~UdUnitsSimObject();
    }
}

void io_src_delete_UdUnitsSimObject(void* address) {
    delete (UdUnitsSimObject*)address;
}

} //extern "C"

struct UnitsMapUdUnitsSimObject {
    UnitsMapUdUnitsSimObject() {
        Trick::UnitsMap* units_map_ptr = Trick::UnitsMap::units_map();
        units_map_ptr->add_param("UdUnitsSimObject_udunits", "1") ;
    }
} umUdUnitsSimObject;

extern "C" {

ATTRIBUTES attrCannonSimObject[] = {
{"cannon", "CANNON", "1", "", "",
  "",
  15,TRICK_STRUCTURED, 0, 0, 0, Language_CPP, 0,
  120, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL},
{"", "", "1", "", "",
  "",
  15,TRICK_VOID, 0, 0, 0, Language_CPP, 0,
  0, NULL, 0, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
  NULL, NULL, NULL, NULL} };

} //extern "C"


void init_attrCannonSimObject() {

    static int initialized ;
    if (initialized) {
        return;
    }
    initialized = 1;

    trick_MM->add_attr_info(std::string(attrCannonSimObject[0].type_name) , &attrCannonSimObject[0], __FILE__ , __LINE__ ) ;
}

extern "C" {

void init_attrCannonSimObject_c_intf() {
    init_attrCannonSimObject() ;
}

size_t io_src_sizeof_CannonSimObject() {
    return sizeof(CannonSimObject) ;
}

void* io_src_allocate_CannonSimObject(int num) {
    CannonSimObject* temp = (CannonSimObject*)calloc(num, sizeof(CannonSimObject));
    for (int ii = 0; ii < num; ++ii) {
        new(&temp[ii]) CannonSimObject();
    }
    return (void*)temp;
}

void io_src_destruct_CannonSimObject(void* address __attribute__((unused)), int num __attribute__((unused))) {
CannonSimObject* temp = (CannonSimObject*)address;
    for (int ii = 0; ii < num; ++ii) {
        temp[ii].~CannonSimObject();
    }
}

void io_src_delete_CannonSimObject(void* address) {
    delete (CannonSimObject*)address;
}

} //extern "C"

struct UnitsMapCannonSimObject {
    UnitsMapCannonSimObject() {
        Trick::UnitsMap* units_map_ptr = Trick::UnitsMap::units_map();
        units_map_ptr->add_param("CannonSimObject_cannon", "1") ;
    }
} umCannonSimObject;

